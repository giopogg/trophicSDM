#ggnet2(intergraph::asNetwork(G_null),arrow.gap = 0.05,arrow.size = 10,label=TRUE)
# glm
if ("glm" %in% algos){
for (i in 1:length(SIMlist)){
print(names(SIMlist[i]))
SIM = SIMlist[[i]]
SIMlist[[i]]$SDM_glm = trophicSDM(Y=SIM$Y,X=SIM$X,G=G_null,formulas=env.form,penal=NULL,method="glm",family=binomial(link = "logit"),iter=iter)
}
}
if ("stan" %in% algos){
for (i in 1:length(SIMlist)){
print(names(SIMlist[i]))
SIM = SIMlist[[i]]
SIMlist[[i]]$SDM_stan = trophicSDM(Y=SIM$Y,X=SIM$X,G=G_null,formulas=env.form,penal=NULL,method="stan_glm",
family=binomial(link = "logit"),iter=iter,run.parallel = F)
}
}
if ("bayes" %in% algos){
for (i in 1:length(SIMlist)){
print(names(SIMlist[i]))
SIM = SIMlist[[i]]
SIMlist[[i]]$SDM_bayes = trophicSDM(Y=SIM$Y,X=SIM$X,G=G_null,formulas=env.form,penal=NULL,method="bayesglm",
family=binomial(link = "logit"),iter=iter)
}
}
###########################################
## Analyse results
for (i in 1:length(SIMlist)){
print(names(SIMlist[i]))
SIM = SIMlist[[i]]
SDM.estimates_stan=SDM.estimates_glm=SDM.estimates_bayes=data.frame( p.est=double(),
est.97=double(),
est.02=double(),
true=double(),
type=factor(levels = c("biotic","abiotic")),
sp.id=factor(),
sp.trophL=factor())
for (j in 1:S){
if ("glm" %in% algos){
print("glm")
model_j = SIM$SDM_glm$model[[paste0("Y",j)]]
post_j = coef(model_j)
print(list(p.est=if(linear)post_j else c(post_j[1], (0:100/100)[which.max(post_j[3]*(0:100/100)**2 + post_j[2]*0:100/100 + post_j[1])], post_j[grepl("Y", row.names(post_j))]),
est.02=if(linear)tryCatch(confint(profile(model_j),prob = 0.95)[,1], warning=function(cond){message(paste0("Warning GLM Y",j));return(NA)}, error=function(cond){message(paste0("Error bayes Y",j));return(NA)}) else NA,
est.97=if(linear)tryCatch(confint(profile(model_j),prob = 0.95)[,2], warning=function(cond)return(NA), error=function(cond)return(NA)) else NA,
true=SIM$B[paste0("Y",j),],
type=as.factor(rep("abiotic",K)),
sp.id=as.factor(j),
sp.trophL=paste("Trophic level", trophL[j])))
SDM.estimates_glm=rbind(SDM.estimates_glm,data.frame(p.est=if(linear)post_j else c(post_j[1], (0:100/100)[which.max(post_j[3]*(0:100/100)**2 + post_j[2]*0:100/100 + post_j[1])], post_j[grepl("Y", row.names(post_j))]),
est.02=if(linear)tryCatch(confint(profile(model_j),prob = 0.95)[,1], warning=function(cond){message(paste0("Warning GLM Y",j));return(NA)}, error=function(cond){message(paste0("Error bayes Y",j));return(NA)}) else NA,
est.97=if(linear)tryCatch(confint(profile(model_j),prob = 0.95)[,2], warning=function(cond)return(NA), error=function(cond)return(NA)) else NA,
true=SIM$B[paste0("Y",j),],
type=as.factor(rep("abiotic",K)),
sp.id=as.factor(j),
sp.trophL=paste("Trophic level", trophL[j])
))}
if ("stan" %in% algos){
print("stan")
model_j = SIM$SDM_stan$model[[paste0("Y",j)]]
post_j = as.data.frame(posterior_summary(model_j))
#post_j = post_j[-nrow(post_j),]
print(list(p.est=if(linear)post_j$Estimate else c(post_j$Estimate[1], (0:100/100)[which.max(post_j$Estimate[3]*(0:100/100)**2 + post_j$Estimate[2]*0:100/100 + post_j$Estimate[1])], post_j$Estimate[grepl("Y", row.names(post_j))]),
est.02=if(linear)post_j$Q2.5 else NA,
est.97=if(linear)post_j$Q97.5 else NA,
true=SIM$B[paste0("Y",j),],
type=as.factor(rep("abiotic",K)),
sp.id=as.factor(j),
sp.trophL=paste("Trophic level", trophL[j])))
SDM.estimates_stan=rbind(SDM.estimates_stan,data.frame(p.est=if(linear)post_j$Estimate else c(post_j$Estimate[1], (0:100/100)[which.max(post_j$Estimate[3]*(0:100/100)**2 + post_j$Estimate[2]*0:100/100 + post_j$Estimate[1])], post_j$Estimate[grepl("Y", row.names(post_j))]),
est.02=if(linear)post_j$Q2.5 else NA,
est.97=if(linear)post_j$Q97.5 else NA,
true=SIM$B[paste0("Y",j),],
type=as.factor(rep("abiotic",K)),
sp.id=as.factor(j),
sp.trophL=paste("Trophic level", trophL[j])
))}
if ("bayes" %in% algos){
print("bayes")
model_j = SIM$SDM_bayes$model[[paste0("Y",j)]]
post_j = coef(model_j)
print(list(p.est=if(linear)post_j else c(post_j[1], (0:100/100)[which.max(post_j[3]*(0:100/100)**2 + post_j[2]*0:100/100 + post_j[1])]),
est.02=if(linear)tryCatch(confint(profile(model_j),prob = 0.95)[,1], error=function(cond){message(paste0("Error bayes Y",j));return(NA)}) else NA,
est.97=if(linear)tryCatch(confint(profile(model_j),prob = 0.95)[,2], error=function(cond)return(NA)) else NA,
true=SIM$B[paste0("Y",j),],
type=as.factor(rep("abiotic",K)),
sp.id=as.factor(j),
sp.trophL=paste("Trophic level", trophL[j])))
SDM.estimates_bayes=rbind(SDM.estimates_bayes,data.frame(p.est=if(linear)post_j else c(post_j[1], (0:100/100)[which.max(post_j[3]*(0:100/100)**2 + post_j[2]*0:100/100 + post_j[1])]),
est.02=if(linear)tryCatch(confint(profile(model_j),prob = 0.95)[,1], error=function(cond){message(paste0("Error bayes Y",j));return(NA)}) else NA,
est.97=if(linear)tryCatch(confint(profile(model_j),prob = 0.95)[,2], error=function(cond)return(NA)) else NA,
true=SIM$B[paste0("Y",j),],
type=as.factor(rep("abiotic",K)),
sp.id=as.factor(j),
sp.trophL=paste("Trophic level", trophL[j])
))}
}
SIMlist[[i]]$SDM.estimates_stan = SDM.estimates_stan
SIMlist[[i]]$SDM.estimates_glm = SDM.estimates_glm
SIMlist[[i]]$SDM.estimates_bayes = SDM.estimates_bayes
}
ggplotEstimates <- function(SIM, algos=c("stan", "glm", "bayes"), shapeLegend=FALSE, colorLegend=FALSE, wrap.type=TRUE, wrap.trophL=TRUE, onlyBio=FALSE, onlyAbio=FALSE){
# Remove intercepts, for which there is no true value to compare to
intercepts=abs(SIM[[paste0("estimates_",algos[1])]]$true)==1
if (onlyBio){cond=!intercepts & SIM[[paste0("estimates_",algos[1])]]$type=="biotic"
}else{if (onlyAbio){cond=!intercepts & SIM[[paste0("estimates_",algos[1])]]$type=="abiotic"
}else cond=!intercepts}
if ("stan" %in% algos){
# Plot pred vs true for stan_glm
p_stan=ggplot(data=SIM$estimates_stan[cond,],aes(x=true,y=p.est,colour=type,shape=sp.id))+
geom_point(cex=1.5) +
#scale_shape_manual(values=c(1:2,4:(S+1))) +
scale_shape_manual(values=rep(19,S)) + scale_colour_brewer(palette="Set1", direction=-1) +
#geom_linerange(mapping=aes(ymin=est.02, ymax=est.97,colour=type))+
geom_abline(intercept=0, slope=1, colour=alpha("black",0.5), linetype="dashed")+
#coord_fixed(ratio=1, xlim=NULL, ylim=NULL, expand=TRUE, clip="on")+
ggtitle("stan_glm()") + xlab("Truth proxy") + ylab("Inferred") +
theme_classic() + theme(panel.grid = element_blank()) +
guides(shape=if(shapeLegend){guide_legend(nrow=5)}else{FALSE},
color=if(colorLegend){guide_legend()}else{FALSE})
if (wrap.type){
if (wrap.trophL){p_stan <- p_stan + facet_wrap(type~sp.trophL, scales="free", nrow=ifelse(onlyBio|onlyAbio,L,2))
}else{p_stan <- p_stan + facet_wrap(.~type, scales="free", nrow=L)}
}else{if (wrap.trophL){p_stan <- p_stan + facet_wrap(sp.trophL~., scales="free", nrow=L)}}
}
if ("glm" %in% algos){
# Plot pred vs true for glm
p_glm=ggplot(data=SIM$estimates_glm[cond,],aes(x=true,y=p.est,colour=type,shape=sp.id))+
geom_point(cex=1.5) +
#scale_shape_manual(values=c(1:2,4:(S+1))) +
scale_shape_manual(values=rep(19,S)) + scale_colour_brewer(palette="Set1", direction=-1) +
#geom_linerange(mapping=aes(ymin=est.02, ymax=est.97,colour=type)) +
geom_abline(intercept=0, slope=1, colour=alpha("black",0.5), linetype="dashed")+
#coord_fixed(ratio=1, xlim=NULL, ylim=NULL, expand=TRUE, clip="on")+
ggtitle("glm()") + xlab("Truth proxy") + ylab("Inferred") +
theme_classic() + theme(panel.grid = element_blank()) +
guides(shape=if(shapeLegend){guide_legend(nrow=5)}else{FALSE},
color=if(colorLegend){guide_legend()}else{FALSE})
if (wrap.type){
if (wrap.trophL){p_glm <- p_glm + facet_wrap(type~sp.trophL, scales="free", nrow=ifelse(onlyBio|onlyAbio,L,2))
}else{p_glm <- p_glm + facet_wrap(.~type, scales="free", nrow=L)}
}else{if (wrap.trophL){p_glm <- p_glm + facet_wrap(sp.trophL~., scales="free", nrow=L)}}
}
if ("bayes" %in% algos){
# Plot pred vs true for bayes
p_bayes=ggplot(data=SIM$estimates_bayes[cond,],aes(x=true,y=p.est,colour=type,shape=sp.id))+
geom_point(cex=1.5) +
#scale_shape_manual(values=c(1:2,4:(S+1))) +
scale_shape_manual(values=rep(19,S)) + scale_colour_brewer(palette="Set1", direction=-1) +
#geom_linerange(mapping=aes(ymin=est.02, ymax=est.97,colour=type))+
geom_abline(intercept=0, slope=1, colour=alpha("black",0.5), linetype="dashed")+
#coord_fixed(ratio=1, xlim=NULL, ylim=NULL, expand=TRUE, clip="on")+
ggtitle("bayes()") + xlab("Truth proxy") + ylab("Inferred") +
theme_classic() + theme(panel.grid = element_blank()) +
guides(shape=if(shapeLegend){guide_legend(nrow=5)}else{FALSE},
color=if(colorLegend){guide_legend()}else{FALSE})
if (wrap.type){
if (wrap.trophL){p_bayes <- p_bayes + facet_wrap(type~sp.trophL, scales="free", nrow=ifelse(onlyBio|onlyAbio,L,2))
}else{p_bayes <- p_bayes + facet_wrap(.~type, scales="free", nrow=L)}
}else{if (wrap.trophL){p_bayes <- p_bayes + facet_wrap(sp.trophL~., scales="free", nrow=L)}}
}
return(list(p_glm=if("glm" %in% algos){p_glm}else NA,
p_stan=if("stan" %in% algos){p_stan}else NA,
p_bayes=if("bayes" %in% algos){p_bayes}else NA))
}
# Compute the correlation coefficients
if (S>=20){
SDM.R2 = sapply(SIMlist,function(SIM){
cond = SIM$SDM.estimates_stan$type=="abiotic" & abs(SIM$SDM.estimates_stan$true)!=1
TL = as.numeric(sub("Trophic level ", "", SIM$SDM.estimates_stan$sp.trophL))
return(list(TL1 = ifelse(var(SIM$SDM.estimates_stan$p.est[cond & TL==1])!=0, cor(SIM$SDM.estimates_stan$p.est[cond & TL==1],SIM$SDM.estimates_stan$true[cond & TL==1], method="spearman"),NA),
TL2 = ifelse(var(SIM$SDM.estimates_stan$p.est[cond & TL==2])!=0, cor(SIM$SDM.estimates_stan$p.est[cond & TL==2],SIM$SDM.estimates_stan$true[cond & TL==2], method="spearman"),NA),
TL3 = ifelse(var(SIM$SDM.estimates_stan$p.est[cond & TL==3])!=0, cor(SIM$SDM.estimates_stan$p.est[cond & TL==3],SIM$SDM.estimates_stan$true[cond & TL==3], method="spearman"),NA)))
})
SDM.R2_pVal = sapply(SIMlist,function(SIM){
cond = SIM$SDM.estimates_stan$type=="abiotic" & abs(SIM$SDM.estimates_stan$true)!=1
TL = as.numeric(sub("Trophic level ", "", SIM$SDM.estimates_stan$sp.trophL))
return(list(TL1 = ifelse(var(SIM$SDM.estimates_stan$p.est[cond & TL==1])!=0, cor.test(SIM$SDM.estimates_stan$p.est[cond & TL==1],SIM$SDM.estimates_stan$true[cond & TL==1], method="spearman",exact=FALSE)$p.value,NA),
TL2 = ifelse(var(SIM$SDM.estimates_stan$p.est[cond & TL==2])!=0, cor.test(SIM$SDM.estimates_stan$p.est[cond & TL==2],SIM$SDM.estimates_stan$true[cond & TL==2], method="spearman",exact=FALSE)$p.value,NA),
TL3 = ifelse(var(SIM$SDM.estimates_stan$p.est[cond & TL==3])!=0, cor.test(SIM$SDM.estimates_stan$p.est[cond & TL==3],SIM$SDM.estimates_stan$true[cond & TL==3], method="spearman",exact=FALSE)$p.value,NA)))
})
options(repr.plot.width = 12, repr.plot.height = 3, repr.plot.res = 150)
df <- cbind(type=rownames(SDM.R2),stack(as.data.frame(SDM.R2)),stack(as.data.frame(SDM.R2_pVal))$values)
names(df) <- c("Trophic.level", "Correlation.coef", "Simulation.model", "p.value")
p.max = 0.2
p <- ggplot(df, aes(Simulation.model, Trophic.level)) +
geom_tile(data = subset(df, p.value<=p.max), aes(fill=Correlation.coef), na.rm=T) +
geom_tile(data = subset(df, p.value>p.max), fill=NA, na.rm=T) +
geom_text(aes(label = ifelse(p.value<=p.max, paste("rho =", round(Correlation.coef, 2), "\np =", round(p.value,2)),
paste("p > ", p.max))), na.rm=T) +
scale_fill_gradient2(low="red", mid="white", high="green4", limits=c(-1,1)) +
theme(panel.background = element_rect(fill=alpha("blue", 0.1),colour=alpha("blue", 0.1),size = 0.5), panel.grid = element_blank()) +
ggtitle("Correlations between inferred and 'true' ABIOTIC parameters, SDM")
ggsave(filename = paste0(figPath, "Correlation_coefficients_SDM_nTrain", round(nRep*nbMerge), ".png"), p, height=5, width=10)
#p
}
######################################################################################################
################# Prediction
### With SDM pred.cov=F or T is the same
for (i in 1:length(SIMlist)){
print(names(SIMlist[i]))
Xnew=SIMlist[[i]]$X[1:nEnv,] #Xnew are the environmental variables that we used to fit the model (actually if Xnew=NULL, this is the default choice)
error_prop_sample=10 #error_prop_sample is an important parameter. The greater it is, the largest the error propagation (and therefore the predictive credible regions). see tSDM_functions for more details
pred_samples=pred_samples
#run predictions
SIMlist[[i]]$SDM.pred_stan=trophicSDM_predict(m=SIMlist[[i]]$SDM_stan,Xnew=Xnew,binary.resp=F,prob.cov=F,pred_samples=pred_samples,error_prop_sample=error_prop_sample)
p.mean.stan.temp=lapply(SIMlist[[i]]$SDM.pred_stan$sp.prediction,FUN=function(x) apply(x$predictions.prob,mean, MARGIN = 1))
SIMlist[[i]]$SDM.p.mean.stan=do.call(cbind, p.mean.stan.temp)
# Compute CI
SIMlist[[i]]$SDM.p.qinf.stan = do.call(cbind,lapply(SIMlist[[i]]$SDM.pred_stan$sp.prediction,FUN=function(x) apply(x$predictions.prob,quantile, MARGIN = 1,probs=0.025)))
SIMlist[[i]]$SDM.p.qsup.stan = do.call(cbind,lapply(SIMlist[[i]]$SDM.pred_stan$sp.prediction,FUN=function(x) apply(x$predictions.prob,quantile, MARGIN = 1,probs=0.975)))
}
for (i in 1:length(SIMlist)){
SIM = SIMlist[[i]]
SIMlist[[i]]$SDM.table_pred=data.frame(obs=as.vector(as.matrix(SIM$prob)), pred=as.vector(as.matrix(SIM$SDM.p.mean.stan)),
est.02=as.vector(as.matrix(SIMlist[[i]]$SDM.p.qinf.stan)), est.97=as.vector(as.matrix(SIMlist[[i]]$SDM.p.qsup.stan)),
sp.name=rep(colnames(SIM$prob),each=nrow(SIM$prob)),
trophL=trophL[as.numeric(sub("Y", "", rep(colnames(SIM$prob),each=nrow(SIM$prob))))])
#plot predicted vs true probabilities of presence
SIMlist[[i]]$SDM.p.predictions <- ggplot(data=SIMlist[[i]]$SDM.table_pred,mapping=aes(x=obs,y=pred,col=factor(sp.name, levels=unique(sp.name)))) +
geom_abline(slope=1,intercept = 0) + guides(col=guide_legend(title=NULL, nrow=10)) +
geom_point(alpha=0.5) + geom_linerange(mapping=aes(ymin=est.02, ymax=est.97), alpha=0.5) +
ggtitle(paste0("Stan-GLM predictions for ", names(SIMlist)[i], " simulations"))+
xlab("Observed presence probability") + ylab("Predicted presence probability") +
facet_wrap(trophL~., labeller="label_both") + theme_minimal() + theme(legend.position="none")
}
#plot predicted vs true probabilities of presence
options(repr.plot.width = 12, repr.plot.height = 8, repr.plot.res = 150)
p <- grid.arrange(arrangeGrob(grobs=lapply(SIMlist, function(SIM)SIM$SDM.p.predictions)))
ggsave(filename = paste0(figPath, "Presence_probability_predictions_SDM_nTrain", round(nRep*nbMerge), ".png"), p, height=7, width=12)
## Check AUS TSS
#We compute AUC and TSS in predictions the AUC and TSS of the simulated data (are probabilities of presence well separated from presence/absences)
figPath=simPath
SIMlist = lapply(SIMlist, function(SIM){SIM[!grepl("m_glm|m_bayes|SDM_glm|SDM_bayes|pEstim", names(SIM))]})
#lapply(SIMlist$GLV_abioticGR, function(SIM)pryr::object_size(SIM))
#save(SIMlist, file=paste0(figPath, "SIMlist.Rdata"))
###################################################################################################
### Load fundamental niches
if ("glvGR" %in% simMethods & file.exists(paste0(simPath, "glv.fundNicheTh.abioticGR.csv"))){
SIMlist$GLV_abioticGR$fundNiche <- read.csv2(paste0(simPath, "glv.fundNicheTh.abioticGR.csv"), row.names=1)
colnames(SIMlist$GLV_abioticGR$fundNiche) <- paste0("Y",1:S)
SIMlist$GLV_abioticGR$fundNiche <- SIMlist$GLV_abioticGR$fundNiche[,spNewNames]
}
if ("glvKbasal" %in% simMethods & file.exists(paste0(simPath, "glv.fundNicheTh.abioticKbasal.csv"))){
SIMlist$GLV_abioticKbasal$fundNiche <- read.csv2(paste0(simPath, "glv.fundNicheTh.abioticKbasal.csv"), row.names=1)
colnames(SIMlist$GLV_abioticKbasal$fundNiche) <- paste0("Y",1:S)
SIMlist$GLV_abioticKbasal$fundNiche <- SIMlist$GLV_abioticKbasal$fundNiche[,spNewNames]
}
if ("rickerKbasal" %in% simMethods & file.exists(paste0(simPath, "ricker.fundNicheTh.abioticKbasal.csv"))){
SIMlist$Ricker_abioticKbasal$fundNiche <- read.csv2(paste0(simPath, "ricker.fundNicheTh.abioticKbasal.csv"), row.names=1)
colnames(SIMlist$Ricker_abioticKbasal$fundNiche) <- paste0("Y",1:S)
SIMlist$Ricker_abioticKbasal$fundNiche <- SIMlist$Ricker_abioticKbasal$fundNiche[,spNewNames]
}
# Compute the fundamental niche for tSDM (this does not depend on if prob.cov=T or F)
# The fundamental niche for SDM = realised niche!
for(i in 1:length(SIMlist)){
SIM=SIMlist[[i]]
intercept=T
SIMlist[[i]]$pFund.mean.stan = SIMlist[[i]]$pFund.qinf.stan = SIMlist[[i]]$pFund.qsup.stan = matrix(NA, nrow=nEnv,ncol=S,
dimnames = list(NULL,names(SIM$m_stan$model)))
for(s in 1:S){
sp_mod = SIM$m_stan$model[[s]]
newdata =  cbind(X1=SIM$X[1:nEnv,"X1"],
data.frame(matrix(1,nrow=nEnv,ncol=length(coef(sp_mod)[-(1:(intercept+K*(2-linear)))]),
dimnames= list(NULL,names(coef(sp_mod)[-(1:(intercept+K*(2-linear)))]))))
)
pred_temp = SDMpredict(m=SIM$m_stan,focal=names(SIM$m_stan$model)[s],newdata = newdata,pred_samples = SIM$m_stan$iter, binary.resp = F,prob.cov = T)
SIMlist[[i]]$pFund.mean.stan[,s] = apply(pred_temp$predictions.prob,1, mean)
SIMlist[[i]]$pFund.qinf.stan[,s] = apply(pred_temp$predictions.prob,1, quantile,0.025)
SIMlist[[i]]$pFund.qsup.stan[,s] = apply(pred_temp$predictions.prob,1, quantile,0.975)
}
}
### Compute CV fundamental & realized for both prob and bin
for(i in 1:length(SIMlist)){
SIM=SIMlist[[i]]
# CV tSDM predictions prob & fundamental niche (notice fund niche does not depend on prob)
probCV = tSDM_CV_SIMUL(mod = SIM$m_stan, K = 5, fundNiche = T, prob.cov = T, iter = SIM$m_stan$iter,
pred_samples = pred_samples, error_prop_sample = error_prop_sample,
fitPreds=F,run.parallel=F, nEnv = nEnv)
SIMlist[[i]]$pCV.mean.stan_prob = probCV$meanPred
SIMlist[[i]]$pCV.qinf.stan_prob = probCV$Pred975
SIMlist[[i]]$pCV.qsup.stan_prob = probCV$Pred025
SIMlist[[i]]$pFundCV.mean.stan = probCV$fundNiche$FN.meanPred
SIMlist[[i]]$pFundCV.qinf.stan = probCV$fundNiche$FN.meanPred
SIMlist[[i]]$pFundCV.qsup.stan = probCV$fundNiche$FN.meanPred
# CV tSDM binary predictions
binCV = tSDM_CV_SIMUL(mod = SIM$m_stan, K=5, fundNiche=F, prob.cov=F,iter=SIM$m_stan$iter,
pred_samples = pred_samples, error_prop_sample=error_prop_sample, fitPreds=F,
run.parallel=F, nEnv = nEnv)
SIMlist[[i]]$pCV.mean.stan_bin = binCV$meanPred
SIMlist[[i]]$pCV.qinf.stan_bin = binCV$Pred975
SIMlist[[i]]$pCV.qsup.stan_bin = binCV$Pred025
#CV SDMs
binCV = tSDM_CV_SIMUL(mod = SIM$SDM_stan, K=5, fundNiche=F, prob.cov=F,iter=SIM$m_stan$iter,
pred_samples = pred_samples, error_prop_sample=error_prop_sample, fitPreds=F,
run.parallel=F, nEnv = nEnv)
SIMlist[[i]]$SDM.pCV.mean.stan = binCV$meanPred
SIMlist[[i]]$SDM.pCV.qinf.stan = binCV$Pred975
SIMlist[[i]]$SDM.pCV.qsup.stan = binCV$Pred025
}
nameOrder = cumsum(table(spNewNames)[spNewNames])[paste0("Y", 1:S)]  # table to alternate between name ordering
for(i in 1:length(SIMlist)){
cat(paste0("### Simul ", i, " ### \n"))
SIM = SIMlist[[i]]
cat(paste0("### plot ", 1, " ### \n"))
plotDistributions(SIM, CV=T, RN=T, prob.cov=T,
plotprey=FALSE, plotpred=FALSE, main=paste0(names(SIMlist)[i],"_CV_Realised_prob"),
filename=paste0(figPath,names(SIMlist)[i],"_CV_Realised_prob.pdf"))
cat(paste0("### plot ", 2, " ### \n"))
plotDistributions(SIM, CV=F, RN=T, prob.cov=T,
plotprey=FALSE, plotpred=FALSE, main=paste0(names(SIMlist)[i],"_Realised_prob"),
filename=paste0(figPath,names(SIMlist)[i],"_Realised_prob.pdf"))
cat(paste0("### plot ", 3, " ### \n"))
plotDistributions(SIM, CV=T, RN=T, prob.cov=F,
plotprey=FALSE, plotpred=FALSE, main=paste0(names(SIMlist)[i],"_CV_Realised_bin"),
filename=paste0(figPath,names(SIMlist)[i],"_CV_Realised_bin.pdf"))
cat(paste0("### plot ", 4, " ### \n"))
plotDistributions(SIM, CV=F, RN=T, prob.cov=F,
plotprey=FALSE, plotpred=FALSE, main=paste0(names(SIMlist)[i],"_Realised_bin"),
filename=paste0(figPath,names(SIMlist)[i],"_Realised_bin.pdf"))
if(!is.null(SIM$fundNiche)){
cat(paste0("### plot ", 5, " ### \n"))
plotDistributions(SIM, CV=T, RN=F, prob.cov=F,
plotprey=FALSE, plotpred=FALSE, main=paste0(names(SIMlist)[i],"_CV_Fund"),
filename=paste0(figPath,names(SIMlist)[i],"_CV_Fund.pdf"))
cat(paste0("### plot ", 6, " ### \n"))
plotDistributions(SIM, CV=F, RN=F, prob.cov=F,
plotprey=FALSE, plotpred=FALSE, main=paste0(names(SIMlist)[i],"_Fund"),
filename=paste0(figPath,names(SIMlist)[i],"_Fund.pdf"))
}
}
# Compute goodness of fit metrics:
# waic, R2, calibration, wasserstein, TSS, AUC,
# for both fundamental and realised niche
for(i in 1:length(SIMlist)){
SIM = SIMlist[[i]]
###### waic
#tSDM
waic.tSDM = unlist(lapply(SIM$m_stan$model,function(x) waic(x)$estimates["waic","Estimate"]))
#SDM
waic.SDM = unlist(lapply(SIM$SDM_stan$model,function(x) waic(x)$estimates["waic","Estimate"]))
###### R2
# R2 bin realized
R2.bin=sapply(spNewNames,function(x){cor(SIM$p.mean.stan_bin[,x],SIM$prob[,x])^2})
# R2 bin CV
R2.CV.bin=sapply(spNewNames,function(x){cor(SIM$pCV.mean.stan_bin[,x],SIM$prob[,x])^2})
# R2 prob realized
R2.prob=sapply(spNewNames,function(x){cor(SIM$p.mean.stan_prob[,x],SIM$prob[,x])^2})
# R2 prob CV
R2.CV.prob=sapply(spNewNames,function(x){cor(SIM$pCV.mean.stan_prob[,x],SIM$prob[,x])^2})
if(!is.null(SIM$fundNiche)){
# R2 fund
R2.fund = sapply(spNewNames,function(x){cor(SIM$p.mean.stan_prob[,x],SIM$fundNiche)^2})
# R2 CV fund
R2.CV.fund = sapply(spNewNames,function(x){cor(SIM$pCV.mean.stan_prob[,x],SIM$prob[,x])^2})
}
#SDM realised
SDM.R2 = sapply(spNewNames,function(x){cor(SIM$SDM.p.mean.stan[,x],SIM$prob[,x])^2})
#SDM realised CV
SDM.CV.R2 = sapply(spNewNames,function(x){cor(SIM$SDM.pCV.mean.stan[,x],SIM$prob[,x])^2})
##### Calibration
# realised bin
calibration.bin = apply(sapply(spNewNames, function(name){
sapply(1:nEnv,function(x)
ifelse(SIM$prob[x,name] < SIM$p.qsup.stan_bin[x,name] &
SIM$prob[x,name]>SIM$p.qinf.stan_bin[x,name], 1, 0))}),
FUN=mean,MARGIN=2)
# realised bin CV
calibration.CV.bin = apply(sapply(spNewNames, function(name){
sapply(1:nEnv,function(x)
ifelse(SIM$prob[x,name] < SIM$pCV.qsup.stan_bin[x,name] &
SIM$prob[x,name]>SIM$pCV.qinf.stan_bin[x,name], 1, 0))}),
FUN=mean,MARGIN=2)
# realised prob
calibration.prob = apply(sapply(spNewNames, function(name){
sapply(1:nEnv,function(x)
ifelse(SIM$prob[x,name] < SIM$p.qsup.stan_prob[x,name] &
SIM$prob[x,name]>SIM$p.qinf.stan_prob[x,name], 1, 0))}),
FUN=mean,MARGIN=2)
# realised prob CV
calibration.CV.prob = apply(sapply(spNewNames, function(name){
sapply(1:nEnv,function(x)
ifelse(SIM$prob[x,name] < SIM$pCV.qsup.stan_prob[x,name] &
SIM$prob[x,name]>SIM$pCV.qinf.stan_prob[x,name], 1, 0))}),
FUN=mean,MARGIN=2)
if(!is.null(SIM$fundNiche)){
# fundamental
calibration.Fund = apply(sapply(spNewNames, function(name){
sapply(1:nEnv,function(x)
ifelse(SIM$fundNiche[x,name] < SIM$pFund.qsup.stan[x,name] &
SIM$fundNiche[x,name]>SIM$pFund.qinf.stan_prob[x,name], 1, 0))}),
FUN=mean,MARGIN=2)
# fundamental CV
calibration.CV.Fund = apply(sapply(spNewNames, function(name){
sapply(1:nEnv,function(x)
ifelse(SIM$fundNiche[x,name] < SIM$pFundCV.qsup.stan[x,name] &
SIM$fundNiche[x,name]>SIM$pFundCV.qinf.stan[x,name], 1, 0))}),
FUN=mean,MARGIN=2)
}
# SDM
SDM.calibration = apply(sapply(spNewNames, function(name){
sapply(1:nEnv,function(x)
ifelse(SIM$fundNiche[x,name] < SIM$SDM.p.qsup.stan[x,name] &
SIM$fundNiche[x,name]>SIM$SDM.p.qinf.stan[x,name], 1, 0))}),
FUN=mean,MARGIN=2)
#SDM CV
SDM.calibration.CV = apply(sapply(spNewNames, function(name){
sapply(1:nEnv,function(x)
ifelse(SIM$fundNiche[x,name] < SIM$SDM.pCV.qsup.stan[x,name] &
SIM$fundNiche[x,name]>SIM$SDM.pCV.qinf.stan[x,name], 1, 0))}),
FUN=mean,MARGIN=2)
####### Wasserstein distance
# bin realized
wass.bin = sapply(1:S,
function(s)transport::wasserstein1d(SIM$prob[,s], SIM$p.mean.stan_bin[,s]))
# bin CV
wass.CV.bin = sapply(1:S,
function(s)transport::wasserstein1d(SIM$prob[,s], SIM$pCV.mean.stan_bin[,s]))
# prob realized
wass.prob = sapply(1:S,
function(s)transport::wasserstein1d(SIM$prob[,s], SIM$p.mean.stan_prob[,s]))
# prob CV
wass.CV.prob = sapply(1:S,
function(s)transport::wasserstein1d(SIM$prob[,s], SIM$pCV.mean.stan_prob[,s]))
if(!is.null(SIM$fundNiche)){
# wass fund
wass.fund = sapply(1:S,
function(s)transport::wasserstein1d(SIM$fundNiche[,s], SIM$pFund.mean.stan[,s]))
# wass CV fund
wass.CV.fund = sapply(1:S,
function(s)transport::wasserstein1d(SIM$fundNiche[,s], SIM$pFundCV.mean.stan[,s]))
}
#SDM realised
SDM.wass.fund = sapply(1:S,
function(s)transport::wasserstein1d(SIM$prob[,s], SIM$SDM.p.mean.stan[,s]))
#SDM realised CV
SDM.wass.fund.CV = sapply(1:S,
function(s)transport::wasserstein1d(SIM$prob[,s], SIM$SDM.pCV.mean.stan[,s]))
####### AUC & TSS
# bin
e_joint = sapply(spNewNames, function(j)
evaluate(p = slice(as.data.frame(SIM$p.mean.stan_bin),rep(row_number(), nRep))[which(SIM$Y[,j]==1),j],
a = slice(as.data.frame(SIM$p.mean.stan_bin),rep(row_number(), nRep))[which(SIM$Y[,j]==0),j]))
AUC.bin = unlist(lapply(e_joint,function(x) x@auc))
TSS.bin = unlist(lapply(e_joint, function(x) max(x@TPR+x@TNR-1)))
# bin CV
e_joint = sapply(spNewNames, function(j)
evaluate(p = slice(as.data.frame(SIM$pCV.mean.stan_bin),rep(row_number(), nRep))[which(SIM$Y[,j]==1),j],
a = slice(as.data.frame(SIM$pCV.mean.stan_bin),rep(row_number(), nRep))[which(SIM$Y[,j]==0),j]))
AUC.CV.bin = unlist(lapply(e_joint,function(x) x@auc))
TSS.CV.bin = unlist(lapply(e_joint, function(x) max(x@TPR+x@TNR-1)))
# prob
e_joint = sapply(spNewNames, function(j)
evaluate(p = slice(as.data.frame(SIM$p.mean.stan_prob),rep(row_number(), nRep))[which(SIM$Y[,j]==1),j],
a = slice(as.data.frame(SIM$p.mean.stan_prob),rep(row_number(), nRep))[which(SIM$Y[,j]==0),j]))
AUC.prob = unlist(lapply(e_joint,function(x) x@auc))
TSS.prob = unlist(lapply(e_joint, function(x) max(x@TPR+x@TNR-1)))
# prob CV
e_joint = sapply(spNewNames, function(j)
evaluate(p = slice(as.data.frame(SIM$pCV.mean.stan_prob),rep(row_number(), nRep))[which(SIM$Y[,j]==1),j],
a = slice(as.data.frame(SIM$pCV.mean.stan_prob),rep(row_number(), nRep))[which(SIM$Y[,j]==0),j]))
AUC.CV.prob = unlist(lapply(e_joint,function(x) x@auc))
TSS.CV.prob = unlist(lapply(e_joint, function(x) max(x@TPR+x@TNR-1)))
#SDM
e_joint = sapply(spNewNames, function(j)
evaluate(p = slice(as.data.frame(SIM$SDM.p.mean.stan),rep(row_number(), nRep))[which(SIM$Y[,j]==1),j],
a = slice(as.data.frame(SIM$SDM.p.mean.stan),rep(row_number(), nRep))[which(SIM$Y[,j]==0),j]))
SDM.AUC = unlist(lapply(e_joint,function(x) x@auc))
SDM.TSS = unlist(lapply(e_joint, function(x) max(x@TPR+x@TNR-1)))
#SDM CV
e_joint = sapply(spNewNames, function(j)
evaluate(p = slice(as.data.frame(SIM$SDM.pCV.mean.stan),rep(row_number(), nRep))[which(SIM$Y[,j]==1),j],
a = slice(as.data.frame(SIM$SDM.pCV.mean.stan),rep(row_number(), nRep))[which(SIM$Y[,j]==0),j]))
AUC.CV.prob = unlist(lapply(e_joint,function(x) x@auc))
TSS.CV.prob = unlist(lapply(e_joint, function(x) max(x@TPR+x@TNR-1)))
# now build a table
}
cat("aaa")
source("~/Documents/GitHub/trophicSDM/tSDM_functions.R", echo=TRUE)
plotDistributions(SIM, CV=T, RN=T, prob.cov=T,
plotprey=FALSE, plotpred=FALSE, main=paste0(names(SIMlist)[i],"_CV_Realised_prob"),
filename=paste0(figPath,names(SIMlist)[i],"_CV_Realised_prob.pdf"))
for(i in 1:length(SIMlist)){
cat(paste0("### Simul ", i, " ### \n"))
SIM = SIMlist[[i]]
cat(paste0("### plot ", 1, " ### \n"))
plotDistributions(SIM, CV=T, RN=T, prob.cov=T,
plotprey=T, plotpred=FALSE, main=paste0(names(SIMlist)[i],"_CV_Realised_prob"),
filename=paste0(figPath,names(SIMlist)[i],"_CV_Realised_prob.pdf"))
cat(paste0("### plot ", 2, " ### \n"))
plotDistributions(SIM, CV=F, RN=T, prob.cov=T,
plotprey=T, plotpred=FALSE, main=paste0(names(SIMlist)[i],"_Realised_prob"),
filename=paste0(figPath,names(SIMlist)[i],"_Realised_prob.pdf"))
cat(paste0("### plot ", 3, " ### \n"))
plotDistributions(SIM, CV=T, RN=T, prob.cov=F,
plotprey=T, plotpred=FALSE, main=paste0(names(SIMlist)[i],"_CV_Realised_bin"),
filename=paste0(figPath,names(SIMlist)[i],"_CV_Realised_bin.pdf"))
cat(paste0("### plot ", 4, " ### \n"))
plotDistributions(SIM, CV=F, RN=T, prob.cov=F,
plotprey=T, plotpred=FALSE, main=paste0(names(SIMlist)[i],"_Realised_bin"),
filename=paste0(figPath,names(SIMlist)[i],"_Realised_bin.pdf"))
if(!is.null(SIM$fundNiche)){
cat(paste0("### plot ", 5, " ### \n"))
plotDistributions(SIM, CV=T, RN=F, prob.cov=F,
plotprey=T, plotpred=FALSE, main=paste0(names(SIMlist)[i],"_CV_Fund"),
filename=paste0(figPath,names(SIMlist)[i],"_CV_Fund.pdf"))
cat(paste0("### plot ", 6, " ### \n"))
plotDistributions(SIM, CV=F, RN=F, prob.cov=F,
plotprey=T, plotpred=FALSE, main=paste0(names(SIMlist)[i],"_Fund"),
filename=paste0(figPath,names(SIMlist)[i],"_Fund.pdf"))
}
}
