nRep = 50     # number of replicates
maxBI = 5     # maximum weight of biotic interaction
niche_breadthGR = 0.3
niche_breadth_Kbasal=0.05
niche_breadthVC=0.3
# Name the directory in which to store the simulations
simPath = paste0("Simulations_S",S,"L",L,"_nEnv",nEnv,"_nRep",nRep,"_maxBI",maxBI,"_job",job,"/")
dir.create(simPath, showWarnings = FALSE)
# Choose the directory from which to load the simulations
simPath = paste0("Simulations_S",S,"L",L,"_nEnv",nEnv,"_nRep",nRep,"_maxBI",maxBI,"_job",job,"/")
}
#library("plot.matrix")
library("igraph")
library("gtools")
library("cheddar")
library("devtools")
library("seqtime") ###???
library("reshape2")
library("gplots")
library("magrittr")
library("purrr")
library("readr")
library("matrixcalc")
library("vegan")
library("parallel")
source("Sim_functions.R")
library("truncnorm")
if (!loadSim){
# Stochastic version
#trophL = NA
#while(length(unique(trophL))!=L) trophL = sample(1:L, size = S, replace = TRUE, prob = 2**(L:1))  # Species trophic levels (predator:prey = 2)
#Stroph = table(trophL)
# Deterministic version
Stroph = round(2**(L:1)/sum(2**(L:1))*S)   # species trophic levels (predator:prey = 2)
names(Stroph) <- 1:L
trophL = rep(1:L, Stroph)                  # number of species in each trophic level
d = 1     # death rate due to intraspecific competition
p = 0.2   # interaction probability between predators and available preys (will be decreasing logarithmically with the trophic level)
spNames <- paste("Sp", 1:S, ".TL", trophL, sep='')  # species names
}
if (loadSim){
IntMat <- as.matrix(read.csv2(paste0(simPath,"InteractionMatrix.csv"), row.names = 1))
PredMat_w <- IntMat
PredMat_w[lower.tri(PredMat_w, diag=TRUE)] <- 0
PredMat <- sign(PredMat_w)
S = ncol(PredMat)
spNames = colnames(PredMat)
trophL = as.numeric(sub(pattern = "Sp.*TL", replacement = "", x = spNames))
Stroph = table(trophL)
Stroph_cum <- cumsum(Stroph)
L = max(trophL)
}else{
PredMat <- matrix(data = 0, nrow=S, ncol=S, dimnames=list(spNames, spNames))
Stroph_cum <- cumsum(Stroph)
cdt_connected = cdt_preys = cdt_preds = FALSE
# Random DAG
while(!cdt_connected|!cdt_preys|!cdt_preds){
PredMat <- matrix(data = 0, nrow=S, ncol=S, dimnames=list(spNames, spNames))
# Each higher trophic level predates all inferior trophic levels
for (l in 2:L){
PredMat[1:Stroph_cum[(l-1)],(Stroph_cum[(l-1)]+1):Stroph_cum[l]] <- sample(c(0,1), replace=TRUE, prob=c(1-p/log(exp(1)-2+l), p/log(exp(1)-2+l)), size=Stroph_cum[l-1]*Stroph[l])
}
# Condition 1 : connected graph
cdt_connected <- is.connected(graph_from_adjacency_matrix(PredMat))
# Condition 2 : at least a prey in the previous trophic level for each predator
cdt_preys <- all(sapply((Stroph[1]+1):S, function(s){
l = trophL[s]  # trophic level
preys = PredMat[ifelse(l>2,Stroph_cum[(l-2)]+1,1):Stroph_cum[(l-1)],s]  # preys of the trophic level just below
return(sum(preys)>0)
}))
#cdt_preys <- all(colSums(PredMat)[-(1:Stroph[1])]>0)  # Analogous condition for all preys
#cdt_preys <- TRUE
# Condition 3 : no predator is very weak, no prey is overpredated (risks of being always absent)
# Choose interaction strenghts
#PredMat_w <- PredMat*runif(S**2,0,maxBI)  # M1 : uniform weights distribution
PredMat_w <- sapply(1:S, function(j){sp <- PredMat[,j]
sp[sp != 0] <- rdirichlet(n=1, alpha=rep(1,sum(sp!=0)))*ifelse(trophL[j]==L,2,2.5)*maxBI
return(sp)})  # M2 : Dirichlet weights distribution
colnames(PredMat_w) <- rownames(PredMat_w)
cdt_preds <- all((colSums(PredMat_w)-colSums(t(PredMat_w)))[-(1:Stroph[1])] > maxBI) &
all((colSums(PredMat_w)-colSums(t(PredMat_w)))[1:Stroph[1]] > -3*maxBI)
#cdt_preds <- TRUE
}
}
# Build graph from PredMat
G = graph_from_adjacency_matrix(t(PredMat))
if (!loadSim){
IntMat <- PredMat_w
IntMat[lower.tri(IntMat)] <- -t(IntMat)[lower.tri(IntMat)]    # negative interactions for the preys
diag(IntMat)[1:Stroph[1]] <- -d    # negative density-dependance for basal species
write.csv2(IntMat, paste0(simPath,"InteractionMatrix.csv"))
}
if (loadSim){
niche_optima <- read.csv2(paste0(simPath,"niche_optima.csv"))[,1]
if (S!=length(niche_optima)) print("WARNING : Wrong number of species")
}else{
envMin = 0; envMax = 1   # min-/maximal environmental abiotic values
envs = seq(envMin, envMax, length.out = nEnv)
niche_optima = round(runif(S, envMin+(envMax-envMin)/20, envMax-(envMax-envMin)/20),2)
write.csv2(niche_optima, paste0(simPath,"niche_optima.csv"), row.names = FALSE)
}
sigma_ricker = 0.2
if(loadSim){
ricker.finalStates.abioticKbasal <- loadData(paste0(simPath,"ricker_finalStates_abioticKbasal.csv"))
nRep = length(ricker.finalStates.abioticKbasal)
ricker.meanAbundances.abioticKbasal <- read.csv2(paste0(simPath,"ricker.meanAbundances.abioticKbasal.csv"), row.names=1)[[1]]
names(ricker.meanAbundances.abioticKbasal) <- spNames
}else{
ricker.finalStates.abioticKbasal <- mclapply(1:nRep, function(x){
final_state=sapply(envs, function(e){
ricker.out.abioticKbasal <- simRicker(Stroph, t(IntMat), spNames, reduceK = TRUE, env=e, niche_optima=niche_optima, sigma=sigma_ricker, death.t=10^-15, tend=1000)
final_state <- t(data.frame(PA=as.numeric( ricker.out.abioticKbasal[,ncol(ricker.out.abioticKbasal)]>0)))
final_abundance <- t(data.frame(AB=ricker.out.abioticKbasal[,ncol(ricker.out.abioticKbasal)]))
return(list(PA=final_state,AB=final_abundance))})
final_state_PA=apply(final_state, MARGIN = 2, FUN = function(x){x[[1]]} )
final_state_AB=apply(final_state, MARGIN = 2, FUN = function(x){x[[2]]} )
return(list(final_state_PA=final_state_PA,final_state_AB=final_state_AB))
},mc.cores = detectCores()-1)
ricker.finalStates.abioticKbasal_PA <- lapply(ricker.finalStates.abioticKbasal, function(final_state){
final_state$final_state_PA <- as.data.frame(final_state$final_state_PA, row.names = spNames)
colnames(final_state$final_state_PA) <- envs
return(final_state$final_state_PA)})
ricker.finalStates.abioticKbasal.merged <- lapply(1:length(ricker.finalStates.abioticKbasal_PA), function(i)
cbind(datasets = as.character(i), rowN = rownames(ricker.finalStates.abioticKbasal_PA[[i]]), ricker.finalStates.abioticKbasal_PA[[i]]))
ricker.finalStates.abioticKbasal.merged <- do.call(rbind, ricker.finalStates.abioticKbasal.merged)
write.csv2(ricker.finalStates.abioticKbasal.merged, paste0(simPath,"ricker_finalStates_abioticKbasal.csv"))
#Abundance-> only needed to compute the fundamental niche
ricker.finalAbundances.abioticKbasal <- lapply(ricker.finalStates.abioticKbasal, function(final_state){
# Set NA values to 0 (computation errors due to too small values)
final_state$final_state_AB[is.na(final_state$final_state_AB)] <- 0
final_state$final_state_AB <- as.data.frame(t(final_state$final_state_AB), row.names = envs)
colnames(final_state$final_state_AB) <- spNames
return(final_state$final_state_AB)})
ricker.meanAbundances.abioticKbasal <- sapply(Reduce(rbind, ricker.finalAbundances.abioticKbasal), function(x)weighted.mean(x, w=x>0))
write.csv2(ricker.meanAbundances.abioticKbasal, paste0(simPath,"ricker.meanAbundances.abioticKbasal.csv"))
}
ricker.finalStates.abioticKbasal <- try( mclapply(1:nRep, function(x){
final_state=sapply(envs, function(e){
ricker.out.abioticKbasal <- simRicker(Stroph, t(IntMat), spNames, reduceK = TRUE, env=e, niche_optima=niche_optima, sigma=sigma_ricker, death.t=10^-15, tend=1000)
final_state <- t(data.frame(PA=as.numeric( ricker.out.abioticKbasal[,ncol(ricker.out.abioticKbasal)]>0)))
final_abundance <- t(data.frame(AB=ricker.out.abioticKbasal[,ncol(ricker.out.abioticKbasal)]))
return(list(PA=final_state,AB=final_abundance))})
final_state_PA=apply(final_state, MARGIN = 2, FUN = function(x){x[[1]]} )
final_state_AB=apply(final_state, MARGIN = 2, FUN = function(x){x[[2]]} )
return(list(final_state_PA=final_state_PA,final_state_AB=final_state_AB))
},mc.cores = detectCores()-1))
ricker.finalStates.abioticKbasal_PA <- lapply(ricker.finalStates.abioticKbasal, function(final_state){
final_state$final_state_PA <- as.data.frame(final_state$final_state_PA, row.names = spNames)
colnames(final_state$final_state_PA) <- envs
return(final_state$final_state_PA)})
ricker.finalStates.abioticKbasal.merged <- lapply(1:length(ricker.finalStates.abioticKbasal_PA), function(i)
cbind(datasets = as.character(i), rowN = rownames(ricker.finalStates.abioticKbasal_PA[[i]]), ricker.finalStates.abioticKbasal_PA[[i]]))
ricker.finalStates.abioticKbasal.merged <- do.call(rbind, ricker.finalStates.abioticKbasal.merged)
ricker.finalStates.abioticKbasal
ricker.finalStates.abioticKbasal.merged <- do.call(rbind, ricker.finalStates.abioticKbasal.merged)
ricker.finalStates.abioticKbasal <- try( mclapply(1:nRep, function(x){
final_state=sapply(envs, function(e){
ricker.out.abioticKbasal <- simRicker(Stroph, t(IntMat), spNames, reduceK = TRUE, env=e, niche_optima=niche_optima, sigma=sigma_ricker, death.t=10^-15, tend=1000)
final_state <- t(data.frame(PA=as.numeric( ricker.out.abioticKbasal[,ncol(ricker.out.abioticKbasal)]>0)))
final_abundance <- t(data.frame(AB=ricker.out.abioticKbasal[,ncol(ricker.out.abioticKbasal)]))
return(list(PA=final_state,AB=final_abundance))})
final_state_PA=apply(final_state, MARGIN = 2, FUN = function(x){x[[1]]} )
final_state_AB=apply(final_state, MARGIN = 2, FUN = function(x){x[[2]]} )
return(list(final_state_PA=final_state_PA,final_state_AB=final_state_AB))
},mc.cores = detectCores()-1))
ricker.finalStates.abioticKbasal
ricker.finalStates.abioticKbasal <- try( mclapply(1:nRep, function(x){
final_state=sapply(envs, function(e){
ricker.out.abioticKbasal <- simRicker(Stroph, t(IntMat), spNames, reduceK = TRUE, env=e, niche_optima=niche_optima, sigma=sigma_ricker, death.t=10^-15, tend=1000)
final_state <- t(data.frame(PA=as.numeric( ricker.out.abioticKbasal[,ncol(ricker.out.abioticKbasal)]>0)))
final_abundance <- t(data.frame(AB=ricker.out.abioticKbasal[,ncol(ricker.out.abioticKbasal)]))
return(list(PA=final_state,AB=final_abundance))})
final_state_PA=apply(final_state, MARGIN = 2, FUN = function(x){x[[1]]} )
final_state_AB=apply(final_state, MARGIN = 2, FUN = function(x){x[[2]]} )
return(list(final_state_PA=final_state_PA,final_state_AB=final_state_AB))
},mc.cores = detectCores()-1))
ricker.finalStates.abioticKbasal_PA <- lapply(ricker.finalStates.abioticKbasal, function(final_state){
final_state$final_state_PA <- as.data.frame(final_state$final_state_PA, row.names = spNames)
colnames(final_state$final_state_PA) <- envs
return(final_state$final_state_PA)})
ricker.finalStates.abioticKbasal
ricker.finalStates.abioticKbasal[[1]]
lapply(ricker.finalStates.abioticKbasal,is.null)
which(lapply(ricker.finalStates.abioticKbasal,is.null))
which(unlist(lapply(ricker.finalStates.abioticKbasal,is.null)))
log("a")
try(log("a"), TRUE)
aa=try(log("a"), TRUE)
aa
aa=try(log("a"))
aa=try(log("a"))
bb="a"
ricker.finalStates.abioticKbasal <- try( mclapply(1:nRep, function(x){
final_state=sapply(envs, function(e){
ricker.out.abioticKbasal <- simRicker(Stroph, t(IntMat), spNames, reduceK = TRUE, env=e, niche_optima=niche_optima, sigma=sigma_ricker, death.t=10^-15, tend=1000)
final_state <- t(data.frame(PA=as.numeric( ricker.out.abioticKbasal[,ncol(ricker.out.abioticKbasal)]>0)))
final_abundance <- t(data.frame(AB=ricker.out.abioticKbasal[,ncol(ricker.out.abioticKbasal)]))
return(list(PA=final_state,AB=final_abundance))})
final_state_PA=apply(final_state, MARGIN = 2, FUN = function(x){x[[1]]} )
final_state_AB=apply(final_state, MARGIN = 2, FUN = function(x){x[[2]]} )
return(list(final_state_PA=final_state_PA,final_state_AB=final_state_AB))
},mc.cores = detectCores()-1))
class(ricker.finalStates.abioticKbasal) == "try-error"
class(ricker.finalStates.abioticKbasal)
ricker.finalStates.abioticKbasal <- try( mclapply(1:nRep, function(x){
final_state=sapply(envs, function(e){
ricker.out.abioticKbasal <- simRicker(Stroph, t(IntMat), spNames, reduceK = TRUE, env=e, niche_optima=niche_optima, sigma=sigma_ricker, death.t=10^-15, tend=1000)
final_state <- t(data.frame(PA=as.numeric( ricker.out.abioticKbasal[,ncol(ricker.out.abioticKbasal)]>0)))
final_abundance <- t(data.frame(AB=ricker.out.abioticKbasal[,ncol(ricker.out.abioticKbasal)]))
return(list(PA=final_state,AB=final_abundance))})
final_state_PA=apply(final_state, MARGIN = 2, FUN = function(x){x[[1]]} )
final_state_AB=apply(final_state, MARGIN = 2, FUN = function(x){x[[2]]} )
return(list(final_state_PA=final_state_PA,final_state_AB=final_state_AB))
},mc.cores = detectCores()-1),TRUE)
class( ricker.finalStates.abioticKbasal )
bb <- mclapply(1:nRep, function(x){
final_state=sapply(envs, function(e){
ricker.out.abioticKbasal <- simRicker(Stroph, t(IntMat), spNames, reduceK = TRUE, env=e, niche_optima=niche_optima, sigma=sigma_ricker, death.t=10^-15, tend=1000)
final_state <- t(data.frame(PA=as.numeric( ricker.out.abioticKbasal[,ncol(ricker.out.abioticKbasal)]>0)))
final_abundance <- t(data.frame(AB=ricker.out.abioticKbasal[,ncol(ricker.out.abioticKbasal)]))
return(list(PA=final_state,AB=final_abundance))})
final_state_PA=apply(final_state, MARGIN = 2, FUN = function(x){x[[1]]} )
final_state_AB=apply(final_state, MARGIN = 2, FUN = function(x){x[[2]]} )
return(list(final_state_PA=final_state_PA,final_state_AB=final_state_AB))
},mc.cores = detectCores()-1)
names(bb)
length(bb)
View(bb)
bb[[1]]
class(bb[[1]])
is.any(class(bb)=="try-error")
class(bb)=="try-error"
lapply(bb, function(x) class(x)=="try-error")
unlist(lapply(bb, function(x) class(x)=="try-error"))
all(unlist(lapply(bb, function(x) class(x)=="try-error")))
sigma_ricker = 0.2
if(loadSim){
ricker.finalStates.abioticKbasal <- loadData(paste0(simPath,"ricker_finalStates_abioticKbasal.csv"))
nRep = length(ricker.finalStates.abioticKbasal)
ricker.meanAbundances.abioticKbasal <- read.csv2(paste0(simPath,"ricker.meanAbundances.abioticKbasal.csv"), row.names=1)[[1]]
names(ricker.meanAbundances.abioticKbasal) <- spNames
}else{
ricker.finalStates.abioticKbasal <- try( mclapply(1:nRep, function(x){
final_state=sapply(envs, function(e){
ricker.out.abioticKbasal <- simRicker(Stroph, t(IntMat), spNames, reduceK = TRUE, env=e, niche_optima=niche_optima, sigma=sigma_ricker, death.t=10^-15, tend=1000)
final_state <- t(data.frame(PA=as.numeric( ricker.out.abioticKbasal[,ncol(ricker.out.abioticKbasal)]>0)))
final_abundance <- t(data.frame(AB=ricker.out.abioticKbasal[,ncol(ricker.out.abioticKbasal)]))
return(list(PA=final_state,AB=final_abundance))})
final_state_PA=apply(final_state, MARGIN = 2, FUN = function(x){x[[1]]} )
final_state_AB=apply(final_state, MARGIN = 2, FUN = function(x){x[[2]]} )
return(list(final_state_PA=final_state_PA,final_state_AB=final_state_AB))
},mc.cores = detectCores()-1))
if(all(unlist(lapply(ricker.finalStates.abioticKbasal, function(x) class(x)=="try-error")))){
ricker.finalStates.abioticKbasal_PA <- lapply(ricker.finalStates.abioticKbasal, function(final_state){
final_state$final_state_PA <- as.data.frame(final_state$final_state_PA, row.names = spNames)
colnames(final_state$final_state_PA) <- envs
return(final_state$final_state_PA)})
ricker.finalStates.abioticKbasal.merged <- lapply(1:length(ricker.finalStates.abioticKbasal_PA), function(i)
cbind(datasets = as.character(i), rowN = rownames(ricker.finalStates.abioticKbasal_PA[[i]]), ricker.finalStates.abioticKbasal_PA[[i]]))
ricker.finalStates.abioticKbasal.merged <- do.call(rbind, ricker.finalStates.abioticKbasal.merged)
write.csv2(ricker.finalStates.abioticKbasal.merged, paste0(simPath,"ricker_finalStates_abioticKbasal.csv"))
#Abundance-> only needed to compute the fundamental niche
ricker.finalAbundances.abioticKbasal <- lapply(ricker.finalStates.abioticKbasal, function(final_state){
# Set NA values to 0 (computation errors due to too small values)
final_state$final_state_AB[is.na(final_state$final_state_AB)] <- 0
final_state$final_state_AB <- as.data.frame(t(final_state$final_state_AB), row.names = envs)
colnames(final_state$final_state_AB) <- spNames
return(final_state$final_state_AB)})
ricker.meanAbundances.abioticKbasal <- sapply(Reduce(rbind, ricker.finalAbundances.abioticKbasal), function(x)weighted.mean(x, w=x>0))
write.csv2(ricker.meanAbundances.abioticKbasal, paste0(simPath,"ricker.meanAbundances.abioticKbasal.csv"))
}
}
ricker.meanAbundances.abioticKbasal
glv.finalStates.abioticGR <- try(
mclapply(1:nRep, function(x){
final_state=sapply(envs, function(e){
glv.out.abioticGR <- simGLV(Stroph, IntMat, spNames, reduceGR = TRUE, env=e, niche_breadth=niche_breadthGR, niche_optima=niche_optima)
final_state <- t(data.frame(PA=as.numeric(glv.out.abioticGR[,ncol(glv.out.abioticGR)]>0)))
final_abundance <- t(data.frame(AB=glv.out.abioticGR[,ncol(glv.out.abioticGR)]))
return(list(PA=final_state,AB=final_abundance))})
final_state_PA=apply(final_state, MARGIN = 2, FUN = function(x){x[[1]]} )
final_state_AB=apply(final_state, MARGIN = 2, FUN = function(x){x[[2]]} )
return(list(final_state_PA=final_state_PA,final_state_AB=final_state_AB))
},mc.cores = detectCores()-1)
)
all(unlist(lapply(glv.finalStates.abioticGR, function(x) class(x)=="try-error")))
unlist(lapply(glv.finalStates.abioticGR, function(x) class(x)=="try-error"))
unlist(lapply(glv.finalStates.abioticGR, class))
all(unlist(lapply(ricker.finalStates.abioticKbasal, function(x) class(x)=="try-error")))
all(unlist(lapply(ricker.finalStates.abioticKbasal, class))
)
unlist(lapply(ricker.finalStates.abioticKbasal, class))
all(unlist(lapply(ricker.finalStates.abioticKbasal, function(x) class(x)=="try-error"))
)
)
all(unlist(lapply(ricker.finalStates.abioticKbasal, function(x) class(x)=="try-error")))
any(unlist(lapply(ricker.finalStates.abioticKbasal, function(x) class(x)=="try-error")))
try(aa=log("a"))
aa=log("a")
aa=try(log("a"))
print(try(log("a"), TRUE))
try(log("a"), TRUE))
try(log("a"), TRUE)
aa=try(log("a"), TRUE)
aa
class(aa)
ricker.fmeanAbundances.abioticKbasal
ricker.meanAbundances.abioticKbasal
is.null(ricker.meanAbundances.abioticKbasal)
fac_inter <- PredMat_w
comp_inter <- t(PredMat_w)
diag(comp_inter)[1:Stroph[1]] <- 1
env = envs                        # environment value at each site
niche_optima  = niche_optima      # niche means
niche_breadthVC = niche_breadthVC               # niche variance
comp_inter = comp_inter           # competition
fac_inter = fac_inter             # facilitation
beta_env = 1 ; beta_comp = 1 ; beta_fac = 1 ; beta_abun = 1  # filters weights
years = 20                        # years number of simulated time-steps
K = S                             # number of individuals in the community
vc.finalStates.abiotic <- try(lapply(1:nRep, function(x){
final_state <- t(simulate_community(env, niche_optima, niche_breadthVC, comp_inter, fac_inter,
beta_env, beta_comp, beta_fac, beta_abun, years, K)[-(S+1)])
colnames(final_state) <- envs
return (final_state)}), TRUE)
class(vc.finalStates.abiotic)
class(vc.finalStates.abiotic[[1]])
length(vc.finalStates.abiotic)
any(unlist(lapply(vc.finalStates.abioticl, function(x) class(x)=="try-error")))
any(unlist(lapply(vc.finalStates.abiotic, function(x) class(x)=="try-error")))
unlist(lapply(vc.finalStates.abiotic, function(x) class(x)=="try-error"))
unlist(lapply(vc.finalStates.abiotic, class))
any(unlist(lapply(glv.finalStates.abioticGR, function(x) class(x)=="try-error")))
rm(list=ls())
# Choose wether to simulate or simply load already simulated datasets
loadSim = FALSE
#setwd("~/Documents/Phd/Futureweb/Code/MY_SCRIPTS/SIM_JEREMY_old")
.libPaths( c( .libPaths(), "~/my_r_libraries/") )
args= commandArgs(trailingOnly = TRUE)
cat(args)
job=args[1]
set.seed(as.numeric(gsub("job_", "", job))*100)
# Parameters
if (!loadSim){
# Choose the main simulation parameter values
S = 20       # number of species
L = 3         # number of trophic levels
nEnv = 51     # number of environmental samples
nRep = 50     # number of replicates
maxBI = 5     # maximum weight of biotic interaction
niche_breadthGR = 0.3
niche_breadth_Kbasal=0.05
niche_breadthVC=0.3
# Name the directory in which to store the simulations
simPath = paste0("Simulations_S",S,"L",L,"_nEnv",nEnv,"_nRep",nRep,"_maxBI",maxBI,"_",job,"/")
dir.create(simPath, showWarnings = FALSE)
}else{
# Choose the main simulation parameter values
S = 5       # number of species
L = 3         # number of trophic levels
nEnv = 51     # number of environmental samples
nRep = 50     # number of replicates
maxBI = 5     # maximum weight of biotic interaction
niche_breadthGR = 0.3
niche_breadth_Kbasal=0.05
niche_breadthVC=0.3
# Name the directory in which to store the simulations
simPath = paste0("Simulations_S",S,"L",L,"_nEnv",nEnv,"_nRep",nRep,"_maxBI",maxBI,"_job",job,"/")
dir.create(simPath, showWarnings = FALSE)
# Choose the directory from which to load the simulations
simPath = paste0("Simulations_S",S,"L",L,"_nEnv",nEnv,"_nRep",nRep,"_maxBI",maxBI,"_job",job,"/")
}
#library("plot.matrix")
library("igraph")
library("gtools")
library("cheddar")
library("devtools")
library("seqtime") ###???
library("reshape2")
#library("gplots")
library("magrittr")
library("purrr")
library("readr")
library("matrixcalc")
library("vegan")
library("parallel")
source("Sim_functions.R")
library("truncnorm")
if (!loadSim){
# Stochastic version
#trophL = NA
#while(length(unique(trophL))!=L) trophL = sample(1:L, size = S, replace = TRUE, prob = 2**(L:1))  # Species trophic levels (predator:prey = 2)
#Stroph = table(trophL)
# Deterministic version
Stroph = round(2**(L:1)/sum(2**(L:1))*S)   # species trophic levels (predator:prey = 2)
names(Stroph) <- 1:L
trophL = rep(1:L, Stroph)                  # number of species in each trophic level
d = 1     # death rate due to intraspecific competition
p = 0.2   # interaction probability between predators and available preys (will be decreasing logarithmically with the trophic level)
spNames <- paste("Sp", 1:S, ".TL", trophL, sep='')  # species names
}
##################################################################################################
####### Build interaction matrix
if (loadSim){
IntMat <- as.matrix(read.csv2(paste0(simPath,"InteractionMatrix.csv"), row.names = 1))
PredMat_w <- IntMat
PredMat_w[lower.tri(PredMat_w, diag=TRUE)] <- 0
PredMat <- sign(PredMat_w)
S = ncol(PredMat)
spNames = colnames(PredMat)
trophL = as.numeric(sub(pattern = "Sp.*TL", replacement = "", x = spNames))
Stroph = table(trophL)
Stroph_cum <- cumsum(Stroph)
L = max(trophL)
}else{
PredMat <- matrix(data = 0, nrow=S, ncol=S, dimnames=list(spNames, spNames))
Stroph_cum <- cumsum(Stroph)
cdt_connected = cdt_preys = cdt_preds = FALSE
# Random DAG
while(!cdt_connected|!cdt_preys|!cdt_preds){
PredMat <- matrix(data = 0, nrow=S, ncol=S, dimnames=list(spNames, spNames))
# Each higher trophic level predates all inferior trophic levels
for (l in 2:L){
PredMat[1:Stroph_cum[(l-1)],(Stroph_cum[(l-1)]+1):Stroph_cum[l]] <- sample(c(0,1), replace=TRUE, prob=c(1-p/log(exp(1)-2+l), p/log(exp(1)-2+l)), size=Stroph_cum[l-1]*Stroph[l])
}
# Condition 1 : connected graph
cdt_connected <- is.connected(graph_from_adjacency_matrix(PredMat))
# Condition 2 : at least a prey in the previous trophic level for each predator
cdt_preys <- all(sapply((Stroph[1]+1):S, function(s){
l = trophL[s]  # trophic level
preys = PredMat[ifelse(l>2,Stroph_cum[(l-2)]+1,1):Stroph_cum[(l-1)],s]  # preys of the trophic level just below
return(sum(preys)>0)
}))
#cdt_preys <- all(colSums(PredMat)[-(1:Stroph[1])]>0)  # Analogous condition for all preys
#cdt_preys <- TRUE
# Condition 3 : no predator is very weak, no prey is overpredated (risks of being always absent)
# Choose interaction strenghts
#PredMat_w <- PredMat*runif(S**2,0,maxBI)  # M1 : uniform weights distribution
PredMat_w <- sapply(1:S, function(j){sp <- PredMat[,j]
sp[sp != 0] <- rdirichlet(n=1, alpha=rep(1,sum(sp!=0)))*ifelse(trophL[j]==L,2,2.5)*maxBI
return(sp)})  # M2 : Dirichlet weights distribution
colnames(PredMat_w) <- rownames(PredMat_w)
cdt_preds <- all((colSums(PredMat_w)-colSums(t(PredMat_w)))[-(1:Stroph[1])] > maxBI) &
all((colSums(PredMat_w)-colSums(t(PredMat_w)))[1:Stroph[1]] > -3*maxBI)
#cdt_preds <- TRUE
}
}
# Build graph from PredMat
G = graph_from_adjacency_matrix(t(PredMat))
if (!loadSim){
IntMat <- PredMat_w
IntMat[lower.tri(IntMat)] <- -t(IntMat)[lower.tri(IntMat)]    # negative interactions for the preys
diag(IntMat)[1:Stroph[1]] <- -d    # negative density-dependance for basal species
write.csv2(IntMat, paste0(simPath,"InteractionMatrix.csv"))
}
##################################################################################################
####### Build niche optima
if (loadSim){
niche_optima <- read.csv2(paste0(simPath,"niche_optima.csv"))[,1]
if (S!=length(niche_optima)) print("WARNING : Wrong number of species")
}else{
envMin = 0; envMax = 1   # min-/maximal environmental abiotic values
envs = seq(envMin, envMax, length.out = nEnv)
niche_optima = round(runif(S, envMin+(envMax-envMin)/20, envMax-(envMax-envMin)/20),2)
write.csv2(niche_optima, paste0(simPath,"niche_optima.csv"), row.names = FALSE)
}
##################################################################################################
####### Run GLV abiotic GR
#### Run abiotic GLV GR
####
if (loadSim){
glv.finalStates.abioticGR <- loadData(paste0(simPath,"glv_finalStates_abioticGR.csv"))
nRep = length(glv.finalStates.abioticGR)
envs = as.numeric(names(glv.finalStates.abioticGR[[1]]))
nEnv = length(envs)
glv.meanAbundances.abioticGR <- read.csv2(paste0(simPath,"glv.meanAbundances.abioticGR.csv"), row.names=1)[[1]]
names(glv.meanAbundances.abioticGR) <- spNames
}else{
glv.finalStates.abioticGR <- try(
mclapply(1:nRep, function(x){
final_state=sapply(envs, function(e){
glv.out.abioticGR <- simGLV(Stroph, IntMat, spNames, reduceGR = TRUE, env=e, niche_breadth=niche_breadthGR, niche_optima=niche_optima)
final_state <- t(data.frame(PA=as.numeric(glv.out.abioticGR[,ncol(glv.out.abioticGR)]>0)))
final_abundance <- t(data.frame(AB=glv.out.abioticGR[,ncol(glv.out.abioticGR)]))
return(list(PA=final_state,AB=final_abundance))})
final_state_PA=apply(final_state, MARGIN = 2, FUN = function(x){x[[1]]} )
final_state_AB=apply(final_state, MARGIN = 2, FUN = function(x){x[[2]]} )
return(list(final_state_PA=final_state_PA,final_state_AB=final_state_AB))
},mc.cores = detectCores()-1)
)
# Presence-absence
glv.finalStates.abioticGR_PA <- lapply(glv.finalStates.abioticGR, function(final_state){
# Set NA values to 0 (computation errors due to too small values)
final_state$final_state_PA[is.na(final_state$final_state_PA)] <- 0
final_state$final_state_PA <- as.data.frame(final_state$final_state_PA, row.names = spNames)
colnames(final_state$final_state_PA) <- envs
return(final_state$final_state_PA)})
glv.finalStates.abioticGR.merged <- lapply(1:length(glv.finalStates.abioticGR_PA), function(i)
cbind(datasets = as.character(i), rowN = rownames(glv.finalStates.abioticGR_PA[[i]]), glv.finalStates.abioticGR_PA[[i]]))
glv.finalStates.abioticGR.merged <- do.call(rbind, glv.finalStates.abioticGR.merged)
write.csv2(glv.finalStates.abioticGR.merged, paste0(simPath,"glv_finalStates_abioticGR.csv"))
#Abundance-> only needed to compute the fundamental niche
glv.finalAbundances.abioticGR <- lapply(glv.finalStates.abioticGR, function(final_state){
# Set NA values to 0 (computation errors due to too small values)
final_state$final_state_AB[is.na(final_state$final_state_AB)] <- 0
final_state$final_state_AB <- as.data.frame(t(final_state$final_state_AB), row.names = envs)
colnames(final_state$final_state_AB) <- spNames
return(final_state$final_state_AB)})
glv.meanAbundances.abioticGR <- sapply(Reduce(rbind, glv.finalAbundances.abioticGR), function(x)weighted.mean(x, w=x>0))
write.csv2(glv.meanAbundances.abioticGR, paste0(simPath,"glv.meanAbundances.abioticGR.csv"))
}
?fread
